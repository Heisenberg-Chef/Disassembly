# SO或者DLL文件简介
inux下的.so文件为共享库，相当于windows下的dll文件。在系统目录/usr/lib/下，我们可以看到很多应用程序库文件（常用的动态链接库和软件包的配置文件）。

# 制作SO
+   编译时gcc后加-fPIC，这可以使gcc产生于位置无关的代码; 
+   连接时，使用-shared，指示生成一个共享库文件; 
+   共享库文件一lib开头+扩展名.so;

# 调用SO
在使用.so文件的时候有2中方法
1.  修改bash_profile --> 不推荐.
2.  添加一个关于DLL的头文件到我们的调用主函数的目录下面

extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。
+ 这个功能十分有用处，因为在C++出现以前，很多代码都是C语言写的，而且很底层的库也是C语言写的，为了更好的支持原来的C代码和已经写好的C语言库，需要在C++中尽可能的支持C，而extern "C"就是其中的一个策略。
+ **extern对应的关键字是static**，static表明变量或者函数只能在本模块中使用，因此，被static修饰的变量或者函数不可能被extern C修饰。被extern "C"修饰的变量和函数是按照C语言方式进行编译和链接的.
```
.SUFFIXES:.c .o
CC=gcc
SRCS=main.c
OBJS=$(SRCS:.c=.o)
EXEC=main
start:$(OBJS)
	$(CC) -o $(EXEC) $(OBJS) -L. -lfunc
.cpp.o:
	$(CC) -Wall -g -o $(@) -c $<
clean:
	rm -f $(OBJS)
	rm -f core*
```
这是对应的makefile 使用-L.来确定链接库的位置.使用-lfunc(注意这里不带lib)来指定连接那个库文件
